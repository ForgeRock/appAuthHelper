# Let's attack your single page app

So, you want to build a "modern" web application. Most likely, this means a "single page app" - a type of web site that relies heavily on JavaScript execution within the browser. You'll probably be using one of the many popular JavaScript frameworks to help you - something like React, Angular, Vue, etc...

Even the most sophisticated JavaScript-based web app is of limited use by itself - after all, there is only so much you can do within the context of the browser itself. Most of the time, the functionality will depend on interaction with some kind of remote systems. Traditionally, the remote component would have been a server-side application layer like Java, ASP.Net, PHP, etc...  Requests from the front-end would be secured with some kind of proprietary session cookie. The remote application layer would probably be designed exclusively for use by the single front-end application.

However, since we are talking about more modern front-end design, it makes sense to also talk about more modern remote systems design. By this, I mean JSON-based REST APIs that are secured using standard OAuth 2 bearer tokens. By designing the back-end systems to use standard OAuth 2 APIs, those services can be used by many different clients. Expanding availability of these services just makes sense - more people using your systems is a good thing. So let's assume there is a rich OAuth 2 API ecosystem available for our front-end application to call.

Okay, so all of this is why you were assigned a task to build a new web app with the latest front-end techniques that relies on OAuth 2 APIs. Now you've done it, so let's start attacking it.

First and foremost, we have to identity what can be exploited in this environment. Static JavaScript code that doesn't make any APIs calls is essentially attack-proof - the worst thing an attacker could do is mess up his own browser.

It is the API usage that we have to look very closely at. You as the app developer know that your app needs an access token in order to call the APIs. You are faced with a number of implementation choices in order to get the token. If you make the wrong choices, then I can successfully attack your system. My end goal is to be able to call those APIs in ways that you don't want me to.

In OAuth 2, the entity which obtains access tokens and uses them to make bearer requests is called the "client". In this case, it's the single page app code running in the user's browser that is the client. The first choice the client developer has to make is how to get the tokens.

The first and simplest mistake you might have made was to register your SPA client with the authorization server (AS) in the same way as a client that runs in a server context. Server-side clients are called "confidential clients" - they have an id and a secret, so they can be identified easily and reliably in the calls made to to the AS. This works for server-side clients because they never expose the client secret.

You might think your client can operate similarly - just put the client id and secret in the JavaScript code for your app. However, that code is sent to my browser when I use your application. I can easily review the code (or the network requests made by the code) and find that client secret. Suddenly it's not so secret, and now that I have it I can fool the AS into thinking that my attack code is really your legitimate client.

To prevent this, you need to register your app as a "public client". This means it has no client secret, and instead relies on other means to reliably identify the legitimate client. Specifically, it relies on a specific, registered "redirect_uri" that points to your SPA. For a mere redirect uri to be sufficient, it should also only use the HTTPS protocol; otherwise, I could set up a man-in-the-middle system and attack your users by intercepting their traffic (stealing their access tokens in the process).

One downside of being a public client is that it has fewer options available for getting access tokens. Essentially, the choice is between the "Implicit Grant" and "Authorization Code Grant". These are the only two that are capable of relying on redirect_uris instead of client secrets.

If you read the OAuth 2 spec or do some searching on-line about which of these two to use, you will be forgiven for choosing the Implicit Grant. It would appear to be the correct choice for single-page apps. However, if you do choose the Implicit Grant you'll be making my job easier. You see, the Implicit Grant passes the access token directly to the redirect_uri in the hash fragment. Security researchers have found many ways to get that raw value from the browser; using window.history is one such mechanism. This is called "access token leakage". The best current practice draft for OAuth 2 clients essentially states that you shouldn't ever use the Implicit Grant to fetch access tokens. Instead, you should use the only remaining choice - the "Authorization Code Grant".

The Authorization Code Grant works by passing a one-time use "code" to the redirect_uri. The code is then used by the client to make a separate POST request to the AS token endpoint, which will finally return the access token as part of the response body. This means of returning the raw access token to the browser is much more secure than the Implicit Grant, since POST responses are never logged or stored in browser memory like the hash fragment.

However, just using the authorization code grant is not enough. What happens if I get the code before your client uses it (maybe from your HTTP server logs)? Then I can submit it to the token endpoint first and get the access token. The solution to this attack is to use "Proof Key for Code Exchange" or PKCE. PKCE was originally designed to prevent attacks on mobile apps, but it applies just as well for single page apps. PKCE works by binding the token adding additional request details to the authorization request as well as to the token request. The end result is that only the original client which made the first request can complete the second; the code is insufficient.
